<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Gomoku AlphaZero - ÊéßÂà∂Èù¢Êùø</title>
    <!-- ÂºïÂÖ• Chart.js Â∫ì -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --board-bg: #d2b48c;
            --primary-blue: #007bff;
            --light-gray: #f8f9fa;
            --border-color: #e0e0e0;
            --text-color: #333;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1000px;
        }
        .panel {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            flex-shrink: 0;
        }
        .board-container {
            position: relative;
            background-color: var(--board-bg);
            border: 2px solid #333;
        }
        #gomoku-board.playable { cursor: pointer; }
        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px; 
        }
        .control-group {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
        }
        h2, h3 {
            margin-top: 0;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            font-weight: 600;
        }
        button, select {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background-color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-color);
        }
        button:hover:not(:disabled) {
            background-color: #f1f3f5;
            border-color: #999;
        }
        button:active:not(:disabled) {
            transform: translateY(1px);
            background-color: #e9ecef;
        }
        button:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .mode-selector .player-controls button.active {
            background-color: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
            font-weight: bold;
        }
        .player-controls {
            display: flex;
            gap: 10px;
        }
        .player-controls button { flex: 1; }
        #info-panel, #status-panel {
            padding: 12px;
            background-color: var(--light-gray);
            border: 1px solid var(--border-color);
            border-radius: 8px; 
            text-align: center;
            font-weight: 500;
            min-height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1.4;
        }
        .replay-controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #replay-controls .player-controls button {
            padding: 10px 8px;
        }
        #win-rate-chart-container {
            margin-top: 15px;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="panel board-panel">
        <h2 id="board-title">Replay Mode</h2>
        <div id="board-sizer" class="board-container">
            <canvas id="gomoku-board"></canvas>
        </div>
    </div>
    
    <div class="panel controls-panel">
        <div class="control-group mode-selector">
            <h3>Mode</h3>
            <div class="player-controls">
                <button id="btn-replay-mode" class="active">Replay</button>
                <button id="btn-play-mode">Play</button>
            </div>
        </div>
        <div id="replay-controls" class="control-group">
            <h3>Replay Controls</h3>
            <div class="replay-controls-wrapper">
                <select id="replay-selector"></select>
                <div class="player-controls">
                    <button id="btn-first">‚èÆÔ∏è</button>
                    <button id="btn-prev">‚è™</button>
                    <button id="btn-play-pause">‚ñ∂Ô∏è</button>
                    <button id="btn-next">‚è©</button>
                    <button id="btn-last">‚è≠Ô∏è</button>
                </div>
                <div>
                    <label for="speed-slider">Speed:</label>
                    <input type="range" id="speed-slider" min="1" max="10" value="2" style="width: 100%;">
                </div>
            </div>
        </div>
        <div id="info-panel">Loading replay info...</div>
        <div id="play-controls" class="control-group" style="display: none;">
            <h3>Play Controls</h3>
            <!-- ‰∏∫Ëøô‰∏™ÂÆπÂô®Ê∑ªÂä†‰∏Ä‰∏™IDÔºåÊñπ‰æøJSÈÄâÊã© -->
            <div id="color-selection-controls" class="player-controls">
                <button id="btn-play-black">Play as ‚ö´</button>
                <button id="btn-play-white">Play as ‚ö™</button>
            </div>
            <!-- ‰øÆÊîπÔºöÂàùÂßãÊó∂ÈöêËóèResetÊåâÈíÆ -->
            <button id="btn-reset" style="margin-top: 10px; width: 100%; display: none;">Reset Game</button>
            <div id="win-rate-chart-container">
                <canvas id="win-rate-chart"></canvas>
            </div>
        </div>
        <div id="status-panel" style="display: none;">Select your color to start.</div>
    </div>
</div>

<script>
/******************************************************************************************
 * Part 1: Constants & Global State
 ******************************************************************************************/
const BOARD_SIZE   = 15;
const CELL_SIZE    = 40;
const MARGIN       = 40; 
const CANVAS_DIMENSION = CELL_SIZE * (BOARD_SIZE - 1) + MARGIN * 2;

const canvas     = document.getElementById('gomoku-board');
const ctx        = canvas.getContext('2d');
const boardSizer = document.getElementById('board-sizer');
boardSizer.style.width  = CANVAS_DIMENSION + 'px';
boardSizer.style.height = CANVAS_DIMENSION + 'px';
canvas.width  = CANVAS_DIMENSION;
canvas.height = CANVAS_DIMENSION;

let currentMode = 'replay', replayData = null, currentReplayStep = 0;
let isAutoPlaying = false, autoPlayInterval = null, autoPlaySpeed = 1000;
let board = [], moveHistory = [], playerColor = null, isPlayerTurn = false, isGameOver = false;

const infoPanel = document.getElementById('info-panel');
const statusPanel = document.getElementById('status-panel');
const replaySelector = document.getElementById('replay-selector');

// ‰∏∫Êñπ‰æøÊéßÂà∂ÔºåËé∑ÂèñÊåâÈíÆÂíåÂÆπÂô®ÁöÑÂºïÁî®
const colorSelectionControls = document.getElementById('color-selection-controls');
const btnReset = document.getElementById('btn-reset');


let winRateChart = null, blackWinRateHistory = [];

/******************************************************************************************
 * Part 2: Drawing Functions (Minified for readability)
 ******************************************************************************************/
function drawGrid(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.strokeStyle='#000';ctx.lineWidth=1;for(let i=0;i<BOARD_SIZE;i++){const p=MARGIN+i*CELL_SIZE;ctx.beginPath();ctx.moveTo(p,MARGIN);ctx.lineTo(p,MARGIN+(BOARD_SIZE-1)*CELL_SIZE);ctx.stroke();ctx.beginPath();ctx.moveTo(MARGIN,p);ctx.lineTo(MARGIN+(BOARD_SIZE-1)*CELL_SIZE,p);ctx.stroke()}ctx.font='16px Arial';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle='#000';for(let c=0;c<BOARD_SIZE;c++){const x=MARGIN+c*CELL_SIZE;const y=MARGIN+(BOARD_SIZE-1)*CELL_SIZE+(MARGIN*.75);ctx.fillText(String.fromCharCode(65+c),x,y)}for(let r=0;r<BOARD_SIZE;r++){const y=MARGIN+(BOARD_SIZE-1-r)*CELL_SIZE;const x=MARGIN+(BOARD_SIZE-1)*CELL_SIZE+(MARGIN*.75);ctx.fillText(''+(r+1),x,y)}}
function drawStone(row,col,color,moveNumber=null){const x=MARGIN+col*CELL_SIZE;const y=MARGIN+row*CELL_SIZE;ctx.font=`${CELL_SIZE*.9}px Arial`;ctx.textAlign='center';ctx.textBaseline='middle';const stoneChar=color===1?'‚ö´':'‚ö™';ctx.fillText(stoneChar,x,y);if(moveNumber!==null){ctx.fillStyle=color===1?'#fff':'#000';ctx.font=`bold ${CELL_SIZE*.4}px Arial`;ctx.fillText(String(moveNumber),x,y)}}
function drawReplayBoard(){drawGrid();if(!replayData)return;const movesToDraw=replayData.moves.slice(0,currentReplayStep);movesToDraw.forEach(([r,c],index)=>{const player=index%2===0?1:-1;drawStone(r,c,player,index+1)})}
function redrawPlayBoard(){drawGrid();moveHistory.forEach((move,index)=>{const[r,c]=move;const color=board[r][c];if(color!==0){drawStone(r,c,color,index+1)}})}
function highlightLastMove(row,col){if(row===undefined||col===undefined)return;const x=MARGIN+col*CELL_SIZE;const y=MARGIN+row*CELL_SIZE;ctx.beginPath();ctx.strokeStyle='red';ctx.lineWidth=2;ctx.strokeRect(x-CELL_SIZE/2,y-CELL_SIZE/2,CELL_SIZE,CELL_SIZE)}
function drawHoverStone(row,col,color){const x=MARGIN+col*CELL_SIZE;const y=MARGIN+row*CELL_SIZE;ctx.save();ctx.globalAlpha=.5;drawStone(row,col,color);ctx.restore()}

/******************************************************************************************
 * Part 3: Win Rate Chart Functions
 ******************************************************************************************/
function initWinRateChart(){const chartCanvas=document.getElementById('win-rate-chart');if(winRateChart){winRateChart.destroy()}winRateChart=new Chart(chartCanvas,{type:'line',data:{labels:[],datasets:[{label:'Black Win Rate',data:[],borderColor:'rgba(0, 0, 0, 0.8)',backgroundColor:'rgba(0, 0, 0, 0.1)',borderWidth:2,tension:.4,fill:true,pointBackgroundColor:'rgba(0, 0, 0, 1)',pointRadius:3,pointHoverRadius:6},{label:'White Win Rate',data:[],borderColor:'rgba(150, 150, 150, 0.8)',backgroundColor:'rgba(200, 200, 200, 0.1)',borderWidth:2,tension:.4,fill:true,pointBackgroundColor:'rgba(255, 255, 255, 1)',pointBorderColor:'rgba(0, 0, 0, 1)',pointRadius:3,pointHoverRadius:6}]},options:{responsive:true,maintainAspectRatio:false,scales:{y:{min:0,max:100,ticks:{callback:value=>value+'%',stepSize:50},grid:{color:'rgba(0, 0, 0, 0.05)'}},x:{title:{display:false},grid:{display:false}}},plugins:{title:{display:true,text:'Win Rate',font:{size:16,weight:'bold'},padding:{top:5,bottom:15}},legend:{display:false},tooltip:{enabled:true,mode:'index',intersect:false,callbacks:{label:function(context){let label=context.dataset.label||'';if(label){label+=': '}if(context.parsed.y!==null){label+=context.parsed.y.toFixed(1)+'%'}return label}}}}}})}
function updateWinRateChart(){if(!winRateChart)return;const whiteWinRateHistory=blackWinRateHistory.map(rate=>100-rate);winRateChart.data.labels=Array.from({length:blackWinRateHistory.length},(_,i)=>i);winRateChart.data.datasets[0].data=blackWinRateHistory;winRateChart.data.datasets[1].data=whiteWinRateHistory;winRateChart.update()}

/******************************************************************************************
 * Part 4: Replay Mode Logic
 ******************************************************************************************/
async function fetchReplayList() {
    const replayControlElements = document.querySelectorAll('#replay-controls button, #replay-controls select, #replay-controls input');
    try {
        const res = await fetch('/get_replay_list');
        const replayFiles = await res.json(); // <-- Áé∞Âú®Êé•Êî∂ÁöÑÊòØÂØπË±°ÂàóË°®
        replaySelector.innerHTML = '';
        
        if (replayFiles.length === 0) {
            replaySelector.innerHTML = '<option disabled selected>No replay files found</option>';
            infoPanel.textContent = 'No replay files available.';
            replayControlElements.forEach(el => el.disabled = true);
            return;
        }

        replayControlElements.forEach(el => el.disabled = false);
        
        replayFiles.forEach(file => {
            const opt = document.createElement('option');
            // [Ê†∏ÂøÉ‰øÆÊîπ] valueÁé∞Âú®ÊòØÂÆåÊï¥ÁöÑÊñá‰ª∂Ë∑ØÂæÑ
            opt.value = file.path; 
            // [Ê†∏ÂøÉ‰øÆÊîπ] ÊòæÁ§∫Êõ¥ÂèãÂ•ΩÁöÑÊñáÊú¨
            opt.textContent = `Iter ${file.iter} - ${file.name}`; 
            replaySelector.appendChild(opt);
        });

        // Âä†ËΩΩÊúÄÊñ∞ÁöÑ‰∏Ä‰∏™ÂõûÊîæ
        if (replayFiles.length > 0) {
            loadReplay(replayFiles[0].path);
        }
    } catch (e) {
        console.error("Failed to fetch replay list:", e);
        replaySelector.innerHTML = '<option disabled selected>Error loading replays</option>';
        infoPanel.textContent = 'Failed to fetch replay list.';
        replayControlElements.forEach(el => el.disabled = true);
    }
}
async function loadReplay(filename) { // <-- ÂèÇÊï∞‰ªé iterNum Âèò‰∏∫ filename
    if (!filename) return;
    try {
        // [Ê†∏ÂøÉ‰øÆÊîπ] URLÁé∞Âú®Áõ¥Êé•‰ΩøÁî®ÂÆåÊï¥ÁöÑÊñá‰ª∂Âêç
        const res = await fetch(`/load_replay/${filename}`); 
        replayData = await res.json();
        currentReplayStep = 0;
        updateReplayView();
        startAutoPlay();
    } catch (e) {
        console.error(`Failed to load replay file ${filename}:`, e);
    }
}
function updateReplayView() {
    if (!replayData) return;
    drawReplayBoard();
    
    document.getElementById('btn-first').disabled = currentReplayStep === 0;
    document.getElementById('btn-prev').disabled = currentReplayStep === 0;
    document.getElementById('btn-next').disabled = currentReplayStep >= replayData.moves.length;
    document.getElementById('btn-last').disabled = currentReplayStep >= replayData.moves.length;

    // [Ê†∏ÂøÉ‰øÆÊîπ] ‰ªéÈÄâÈ°πÁöÑÊñáÊú¨‰∏≠Ëé∑ÂèñÊòæÁ§∫‰ø°ÊÅØ
    const selectedOptionText = replaySelector.options[replaySelector.selectedIndex].text;
    let info = `<b>${selectedOptionText}</b><br>`;
    
    // ... (Ââ©‰∏ãÁöÑÈÄªËæëÂÆåÂÖ®‰∏çÂèò) ...
    let challengerCrown = '', defenderCrown = '';
    const isGameFinished = currentReplayStep === replayData.moves.length;
    if (isGameFinished && replayData.winner !== "Draw") {
        if (replayData.challenger_color === replayData.winner) challengerCrown = 'üëë';
        if (replayData.defender_color === replayData.winner) defenderCrown = 'üëë';
    }
    const challengerEmoji = replayData.challenger_color === 'Black' ? '‚ö´' : '‚ö™';
    const defenderEmoji = replayData.defender_color === 'Black' ? '‚ö´' : '‚ö™';

    info += `Challenger: ${challengerEmoji}${challengerCrown}<br>Defender: ${defenderEmoji}${defenderCrown}<br>`;
    
    if (currentReplayStep > 0 && currentReplayStep <= replayData.moves.length) {
        const [r, c] = replayData.moves[currentReplayStep - 1];
        highlightLastMove(r, c);
        info += `Move ${currentReplayStep}/${replayData.moves.length}. Turn: ${currentReplayStep % 2 === 0 ? '‚ö™' : '‚ö´'}<br>`;
    }

    if (isGameFinished && replayData.winner === "Draw") {
        info += `Game Over. Draw`;
    }
    
    infoPanel.innerHTML = info;
}
function setReplayStep(step){if(!replayData)return;currentReplayStep=Math.max(0,Math.min(step,replayData.moves.length));updateReplayView();if(currentReplayStep===replayData.moves.length)stopAutoPlay()}
function startAutoPlay(){if(isAutoPlaying)return;isAutoPlaying=true;document.getElementById('btn-play-pause').textContent='‚è∏Ô∏è';autoPlayInterval=setInterval(()=>setReplayStep(currentReplayStep+1),autoPlaySpeed)}
function stopAutoPlay(){if(!isAutoPlaying)return;isAutoPlaying=false;document.getElementById('btn-play-pause').textContent='‚ñ∂Ô∏è';clearInterval(autoPlayInterval)}

/******************************************************************************************
 * Part 5: Play vs. AI Logic
 ******************************************************************************************/
function resetPlayMode() {
    board = Array(BOARD_SIZE).fill(0).map(()=>Array(BOARD_SIZE).fill(0));
    moveHistory = [];
    drawGrid();
    playerColor = null;
    isPlayerTurn = false;
    isGameOver = false;
    statusPanel.textContent = 'Select your color to start.';
    blackWinRateHistory = [50.0];
    initWinRateChart();
    updateWinRateChart();

    // ‰øÆÊîπÔºöÊòæÁ§∫È¢úËâ≤ÈÄâÊã©ÊåâÈíÆÔºåÈöêËóèÈáçÁΩÆÊåâÈíÆ
    colorSelectionControls.style.display = 'flex';
    btnReset.style.display = 'none';
}

async function startGame(userPlaysAs) {
    // Ë∞ÉÁî® resetPlayMode ‰ºöÈáçÁΩÆÊåâÈíÆÁä∂ÊÄÅÔºåÊâÄ‰ª•Êàë‰ª¨Âú®ËøôÈáå‰øÆÊîπ
    resetPlayMode(); 

    // ‰øÆÊîπÔºöÈöêËóèÈ¢úËâ≤ÈÄâÊã©ÊåâÈíÆÔºåÊòæÁ§∫ÈáçÁΩÆÊåâÈíÆ
    colorSelectionControls.style.display = 'none';
    btnReset.style.display = 'block';

    playerColor = userPlaysAs;
    if (playerColor === 1) {
        isPlayerTurn = true;
        statusPanel.textContent = 'Your turn (‚ö´).';
    } else {
        isPlayerTurn = false;
        statusPanel.textContent = 'AI is thinking...';
        await makeAIMove(null); 
    }
}

async function makeAIMove(humanMove) {
    try {
        const playerToMove = humanMove ? playerColor : 1;
        const res = await fetch('/move', {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ board, move: humanMove, player_to_move: playerToMove })
        });
        if (!res.ok) throw new Error(`Server responded with ${res.status}`);
        const data = await res.json();

        if (data.black_win_rate !== undefined) {
            blackWinRateHistory.push(data.black_win_rate);
            updateWinRateChart();
        }

        if (data.ai_move){
            const [r,c] = data.ai_move;
            const aiColor = playerColor * -1;
            board[r][c] = aiColor;
            moveHistory.push([r, c]); 
            redrawPlayBoard();
            highlightLastMove(r,c);
        }

        if (data.game_over) {
            isGameOver = true;
            isPlayerTurn = false;
            let winnerText = data.winner === 0 ? 'Draw!' : (data.winner === playerColor ? 'You Win!' : 'AI Wins!');
            statusPanel.textContent = `Game Over. ${winnerText}`;
        } else {
            isPlayerTurn = true;
            statusPanel.textContent = `Your turn (${playerColor===1?'‚ö´':'‚ö™'}).`;
        }
    } catch(e) {
        console.error("Error during AI move:", e);
        statusPanel.textContent = 'Error communicating with server.';
    }
}

/******************************************************************************************
 * Part 6: Event Listeners & Initialization
 ******************************************************************************************/
function setupEventListeners() {
    document.getElementById('btn-replay-mode').addEventListener('click', ()=>switchMode('replay'));
    document.getElementById('btn-play-mode').addEventListener('click', ()=>switchMode('play'));

    replaySelector.addEventListener('change', (e)=>loadReplay(e.target.value));
    document.getElementById('btn-first').addEventListener('click', ()=>setReplayStep(0));
    document.getElementById('btn-prev').addEventListener('click', ()=>setReplayStep(currentReplayStep-1));
    document.getElementById('btn-next').addEventListener('click', ()=>setReplayStep(currentReplayStep+1));
    document.getElementById('btn-last').addEventListener('click', ()=>setReplayStep(replayData?replayData.moves.length:0));
    document.getElementById('btn-play-pause').addEventListener('click', ()=>isAutoPlaying?stopAutoPlay():startAutoPlay());
    document.getElementById('speed-slider').addEventListener('input', (e)=>{
        autoPlaySpeed = 1500 - (e.target.value * 140);
        if (isAutoPlaying){ stopAutoPlay(); startAutoPlay(); }
    });

    document.getElementById('btn-play-black').addEventListener('click', ()=>startGame(1));
    document.getElementById('btn-play-white').addEventListener('click', ()=>startGame(-1));
    // btn-resetÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®‰∏çÈúÄË¶ÅÊîπÂä®
    btnReset.addEventListener('click', resetPlayMode);

    canvas.addEventListener('click', async (e) => {
        if (currentMode !== 'play' || !isPlayerTurn || isGameOver) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const c = Math.round((x - MARGIN) / CELL_SIZE);
        const r = Math.round((y - MARGIN) / CELL_SIZE);
        if (r<0||r>=BOARD_SIZE||c<0||c>=BOARD_SIZE||board[r][c]!==0) return;

        isPlayerTurn = false;
        statusPanel.textContent = 'AI is thinking...';
        board[r][c] = playerColor;
        moveHistory.push([r, c]);
        redrawPlayBoard();
        highlightLastMove(r,c);
        
        await makeAIMove([r,c]);
    });

    canvas.addEventListener('mousemove', (e)=>{
        if (currentMode !== 'play' || !isPlayerTurn || isGameOver) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const c = Math.round((x - MARGIN) / CELL_SIZE);
        const r = Math.round((y - MARGIN) / CELL_SIZE);
        
        redrawPlayBoard();
        if (r>=0 && r<BOARD_SIZE && c>=0 && c<BOARD_SIZE && board[r][c]===0){
            drawHoverStone(r, c, playerColor);
        }
    });

    canvas.addEventListener('mouseleave', ()=>{
        if (currentMode === 'play') redrawPlayBoard();
    });
}

function switchMode(mode) {
    currentMode = mode;
    stopAutoPlay();
    
    const replayControls = document.getElementById('replay-controls');
    const playControls = document.getElementById('play-controls');
    const btnReplay = document.getElementById('btn-replay-mode');
    const btnPlay = document.getElementById('btn-play-mode');
    const boardTitle = document.getElementById('board-title');
    
    if (mode === 'replay'){
        replayControls.style.display = 'block';
        infoPanel.style.display = 'flex';
        playControls.style.display = 'none';
        statusPanel.style.display = 'none';

        btnReplay.classList.add('active');
        btnPlay.classList.remove('active');
        boardTitle.textContent = 'Replay Mode';
        canvas.classList.remove('playable');
        fetchReplayList();
    } else { 
        replayControls.style.display = 'none';
        infoPanel.style.display = 'none';
        playControls.style.display = 'block';
        statusPanel.style.display = 'flex';

        btnReplay.classList.remove('active');
        btnPlay.classList.add('active');
        boardTitle.textContent = 'Play vs. AI';
        canvas.classList.add('playable');
        resetPlayMode();
    }
}

window.onload = ()=>{
    drawGrid();
    setupEventListeners();
    switchMode('replay');
};
</script>
</body>
</html>